<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FaceTimey - Group Video Call</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <style>
      /* General Body and Container */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Google Sans', 'Roboto', Arial, sans-serif; /* Prefer Google fonts */
        background-color: #1a1a1a; /* Dark background for the entire page */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden; /* Hide scrollbars on body */
        color: #e8eaed; /* Light text color for contrast */
      }

      .container {
        width: 98%; /* Slightly wider container */
        max-width: 1400px; /* Increased max-width */
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #202124; /* Darker background for the main content area */
        border-radius: 8px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4); /* More pronounced shadow */
        padding: 20px; /* Add some padding around the container */
        height: 95vh; /* Take up more vertical space */
        overflow: hidden; /* Hide container scrollbars, let internal elements handle it */
      }

      h1 {
        display: none; /* Hide the main title, Google Meet is very minimal */
      }

      /* Room Info - Positioned more subtly */
      #roomInfo {
        margin-top: 10px;
        font-size: 14px;
        color: #9aa0a6; /* Muted grey for room info */
        text-align: center;
        padding: 5px 15px;
        background-color: #2f3032;
        border-radius: 20px;
        margin-bottom: 20px;
      }

      #roomIdDisplay {
        color: #e8eaed;
        font-weight: normal; /* Less bold than before */
      }

      /* Video Container for multiple videos */
      #videoContainer {
        flex-grow: 1;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Flexible grid for videos */
        gap: 15px;
        width: 100%;
        padding: 0;
        margin-top: 0;
        transition: all 0.3s ease-in-out;
        min-height: 200px;
        overflow-y: auto; /* Allow scrolling if many videos */
      }

      .video-wrapper {
        position: relative;
        background-color: #000;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        aspect-ratio: 16/9; /* Maintain aspect ratio */
      }

      .video-wrapper video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px;
        border: none;
      }

      .video-wrapper .user-id-label {
        position: absolute;
        bottom: 5px;
        left: 5px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1;
      }

      /* Controls Section */
      .controls {
        display: flex;
        justify-content: center;
        gap: 20px; /* Increased gap between buttons */
        margin: 20px 0 10px 0; /* Adjust margin to give more space to chat */
        padding: 10px 0;
        background-color: #2f3032; /* Slightly different background for controls */
        border-radius: 8px;
        width: 100%;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.2);
      }

      button {
        padding: 10px 18px; /* Adjusted padding for a more compact look */
        font-size: 15px;
        color: #e8eaed; /* Light text for buttons */
        background-color: #3c4043; /* Darker grey for active buttons */
        border: none;
        border-radius: 24px; /* Pill-shaped buttons */
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
        display: flex; /* Allows icon and text alignment */
        align-items: center;
        gap: 8px; /* Space between icon and text if applicable */
      }

      button:hover {
        background-color: #5f6368; /* Lighter grey on hover */
        transform: translateY(-2px); /* Slight lift effect */
      }

      button:active {
        transform: translateY(0);
      }

      .controls button:disabled {
        background-color: #4a4a4a;
        color: #9aa0a6;
        cursor: not-allowed;
      }

      /* Specific button styles for mic/camera toggles */
      #toggleAudio:not(.active),
      #toggleVideo:not(.active) {
        background-color: #ea4335; /* Red for active mute/camera off state (when not active) */
      }

      #toggleAudio.active,
      #toggleVideo.active { /* Class to add when active (e.g., mic on) */
        background-color: #3c4043; /* Dark grey when active */
      }

      #shareScreen.active { /* Style for when screen sharing is active */
        background-color: #4CAF50; /* Green color when active */
        color: #fff;
      }


      #disconnect {
        background-color: #ea4335; /* Red for disconnect button */
      }

      #disconnect:hover {
        background-color: #d1392c; /* Darker red on hover */
      }

      /* Call Status */
      .callStatus {
        margin-top: 10px;
        font-size: 14px;
        color: #ea4335; /* Red for warning/disconnected status */
        font-weight: normal;
      }

      /* Fullscreen Icons */
      .fullscreen-icon-container {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: row; /* Icons in a row */
        gap: 8px;
        z-index: 10;
      }

      .fullscreen-icon-container i {
        color: #e8eaed; /* Light color for icons */
        font-size: 18px; /* Smaller icon size */
        cursor: pointer;
        background-color: rgba(60, 64, 67, 0.7); /* Dark semi-transparent background */
        border-radius: 50%;
        padding: 8px; /* Larger padding for easier clicking */
        transition: background-color 0.3s;
      }

      .fullscreen-icon-container i:hover {
        background-color: rgba(95, 99, 104, 0.9); /* Lighter on hover */
      }

      /* Chat UI */
      .chat-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        margin-top: 10px; /* Reduced margin-top to fit better */
        background-color: #2f3032; /* Match control bar background */
        border-radius: 8px;
        padding: 15px;
        flex-shrink: 0; /* Prevent chat from shrinking too much */
        max-height: 30vh; /* Allow chat to take up to 30% of viewport height initially */
        min-height: 120px; /* Minimum height to remain usable */
      }

      .chat-messages {
        flex-grow: 1; /* Allow messages to take available height */
        overflow-y: auto;
        padding: 10px;
        background-color: #3c4043; /* Darker background for messages */
        border: none; /* Remove border */
        border-radius: 5px;
        color: #e8eaed; /* Light text for messages */
        margin-bottom: 10px; /* Space before input */
      }

      .chat-messages div {
        margin-bottom: 8px; /* Space between messages */
        line-height: 1.4;
        word-wrap: break-word; /* Ensure long words break */
      }

      /* Chat message specific styles */
      .chat-message.self-message {
        text-align: right;
        color: #8ab4f8; /* A different color for self messages */
      }
      .chat-message.remote-message {
        text-align: left;
        color: #e8eaed;
      }


      .chat-input-container {
        display: flex;
        /* margin-top: 15px; Removed, handled by .chat-messages margin-bottom */
        gap: 10px;
        flex-shrink: 0; /* Prevent input from shrinking */
      }

      .chat-input {
        flex-grow: 1; /* Allow input to take remaining space */
        padding: 10px 15px;
        font-size: 15px;
        border: none;
        border-radius: 20px; /* Rounded input field */
        background-color: #3c4043; /* Dark background for input */
        color: #e8eaed;
        outline: none; /* Remove outline on focus */
      }

      .chat-input::placeholder {
        color: #9aa0a6; /* Muted placeholder text */
      }

      .chat-send-button {
        padding: 10px 20px;
        background-color: #8ab4f8; /* Google Meet blue for send button */
        color: #202124; /* Dark text on blue background */
        font-weight: bold;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        transition: background-color 0.3s;
        flex-shrink: 0; /* Prevent button from shrinking */
      }

      .chat-send-button:hover {
        background-color: #a0c3ff; /* Lighter blue on hover */
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .container {
            padding: 10px;
            height: auto; /* Allow container to grow on smaller screens */
            max-height: 100vh; /* Max height for container */
            overflow-y: auto; /* Allow scrolling if content overflows */
        }

        #videoContainer {
          grid-template-columns: 1fr; /* Stack videos on small screens */
          height: auto; /* Allow height to adjust */
          min-height: 150px;
        }

        .video-wrapper {
          height: 200px; /* Fixed height for videos on mobile */
          max-height: unset; /* Remove max-height constraint */
          align-self: auto; /* Reset align-self */
        }

        .controls {
          flex-direction: column; /* Stack controls vertically */
          gap: 10px;
          padding: 10px;
          margin: 15px 0 10px 0; /* Adjust margins */
        }

        button {
          width: 100%; /* Full width buttons */
        }

        .chat-container {
            margin-top: 10px;
            max-height: 250px; /* Fixed max height for chat on small screens */
            min-height: 100px;
        }

        .chat-messages {
            min-height: 80px; /* Ensure chat messages have a minimum height */
        }
      }

       /* Add a subtle scrollbar style for chat messages */
       .chat-messages::-webkit-scrollbar {
        width: 8px;
        border-radius: 4px;
       }

       .chat-messages::-webkit-scrollbar-track {
        background: #2f3032;
        border-radius: 4px;
       }

       .chat-messages::-webkit-scrollbar-thumb {
        background-color: #5f6368;
        border-radius: 4px;
       }

       .chat-messages::-webkit-scrollbar-thumb:hover {
        background-color: #7a7d80;
       }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>FaceTimey - Group Video Call</h1>

      <div id="roomInfo">
        <span>Room ID: <strong id="roomIdDisplay"></strong></span>
        <span>Your ID: <strong id="myUserIdDisplay"></strong></span>
      </div>

      <div id="videoContainer" class="fullscreen-container">
        <div class="video-wrapper">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="user-id-label">You</div>
          <div class="fullscreen-icon-container">
            <i
              class="fas fa-expand"
              data-target="localVideo"
              title="Go Full Screen"
            ></i>
            <i
              class="fas fa-compress"
              data-target="localVideo"
              style="display: none"
              title="Exit Full Screen"
            ></i>
          </div>
        </div>
        </div>

      <div class="controls">
        <button id="toggleVideo"><i class="fas fa-video"></i> Turn Camera Off</button>
        <button id="toggleAudio"><i class="fas fa-microphone"></i> Mute</button>
        <button id="shareScreen"><i class="fas fa-desktop"></i> Share Screen</button>
        <button id="disconnect"><i class="fas fa-phone-slash"></i> Leave Call</button>
      </div>

      <div class="callStatus" id="callStatus"></div>

      <div class="chat-container">
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-container">
          <input
            type="text"
            id="chatInput"
            class="chat-input"
            placeholder="Type a message..."
          />
          <button class="chat-send-button" id="sendMessageButton">Send</button>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
 const socket = io();

      const localVideo = document.getElementById("localVideo");
      const videoContainer = document.getElementById("videoContainer");
      const toggleVideoBtn = document.getElementById("toggleVideo");
      const toggleAudioBtn = document.getElementById("toggleAudio");
      const disconnectBtn = document.getElementById("disconnect");
      const shareScreenBtn = document.getElementById("shareScreen");
      const chatMessages = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const sendMessageButton = document.getElementById("sendMessageButton");
      const callStatus = document.getElementById("callStatus");
      const roomIdDisplay = document.getElementById("roomIdDisplay");
      const myUserIdDisplay = document.getElementById("myUserIdDisplay");

      let localStream;
      // Store multiple peer connections, keyed by the remote socket ID
      const peerConnections = {};
      let roomId;
      let myUserId; // To store the user's chosen ID
      let screenStream;
      let isScreenSharing = false;

      const configuration = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      };

      // Helper to get local video track
      function getLocalVideoTrack() {
        return localStream ? localStream.getVideoTracks()[0] : null;
      }

      // Helper to get local audio track
      function getLocalAudioTrack() {
        return localStream ? localStream.getAudioTracks()[0] : null;
      }

      // Initialize media
      async function initMedia() {
        try {
          const constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
            audio: true,
          };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          localVideo.srcObject = localStream;

          // Initial state: Set active class if tracks are initially enabled.
          if (getLocalVideoTrack()?.enabled) {
            toggleVideoBtn.classList.add('active');
            toggleVideoBtn.innerHTML = '<i class="fas fa-video"></i> Turn Camera Off';
          }
          if (getLocalAudioTrack()?.enabled) {
            toggleAudioBtn.classList.add('active');
            toggleAudioBtn.innerHTML = '<i class="fas fa-microphone"></i> Mute';
          }

        } catch (e) {
          alert("Could not get user media. Please ensure camera and microphone permissions are granted.");
          console.error("Error initializing media:", e);
        }
      }

      initMedia();

      // Prompt user to enter room ID and user ID
      roomId = prompt("Enter room ID to join or create:");
      if (!roomId) {
        roomId = "default-room-" + Math.random().toString(36).substring(2, 9);
        alert("No room ID entered. Joining a random room: " + roomId);
      }
      myUserId = prompt("Enter your user ID (e.g., 'Alice', 'Bob'):");
      if (!myUserId) {
        myUserId = "user-" + Math.random().toString(36).substring(2, 6);
        alert("No user ID entered. Using random ID: " + myUserId);
      }

      roomIdDisplay.textContent = roomId;
      myUserIdDisplay.textContent = myUserId;

      socket.emit("join-room", roomId, myUserId);

      // When a new user connects to the room
      // newUserId is the socket.id of the new user, newUserName is their chosen display name
      socket.on("user-connected", (newUserId, newUserName) => {
        callStatus.textContent = `User ${newUserName} connected.`;
        // Immediately try to call the new user to establish a peer connection
        callUser(newUserId, newUserName);
      });

      // When you join, the server sends a list of existing users in the room
      socket.on("existing-users", (existingUserIdsAndNames) => {
        // existingUserIdsAndNames should be an array of objects like { id: socketId, name: userName }
        existingUserIdsAndNames.forEach(({ id: userId, name: userName }) => {
          callUser(userId, userName); // Initiate call with each existing user
        });
      });

      socket.on("signal", async ({ senderId, signal }) => {
        // If we don't have a peer connection with this sender yet, create one
        // This is crucial for handling incoming offers from new users
        if (!peerConnections[senderId]) {
          // If the server didn't send the username with the signal, we might just use the socketId for the label initially
          createPeerConnection(senderId, senderId.substring(0, 5)); // Use a truncated ID for label
        }

        const pc = peerConnections[senderId];
        if (!pc) { // Fallback if creation somehow failed
          console.error("Peer connection not found for senderId:", senderId);
          return;
        }

        try {
          if (signal.type === "offer") {
            await pc.setRemoteDescription(new RTCSessionDescription(signal));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit("signal", { targetId: senderId, signal: pc.localDescription });
          } else if (signal.type === "answer") {
            await pc.setRemoteDescription(new RTCSessionDescription(signal));
          } else if (signal.candidate) {
            // Ensure candidate is an RTCIceCandidate object
            await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
          }
        } catch (e) {
          console.error("Error handling signal from", senderId, e);
        }
      });

      socket.on("user-disconnected", (userId) => {
        callStatus.textContent = `User ${userId} disconnected.`;
        removePeerConnection(userId);
      });

      socket.on("call-ended", () => {
        callStatus.textContent = "The call has been ended by another user.";
        endCall(); // Clean up if someone explicitly ended the call for everyone
      });

      // Create peer connection for a specific remote user
      // Now accepts a userName to display
      function createPeerConnection(remoteSocketId, remoteUserName) {
        if (peerConnections[remoteSocketId]) {
          console.warn(`Peer connection to ${remoteSocketId} already exists. Returning existing.`);
          return peerConnections[remoteSocketId]; // Return existing if it exists
        }

        const pc = new RTCPeerConnection(configuration);

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            // Send candidate to the specific remote user
            socket.emit("signal", { targetId: remoteSocketId, signal: { candidate: event.candidate } });
          }
        };

        pc.ontrack = (event) => {
          console.log(`Received track from ${remoteSocketId}`);
          // Find or create a video element for this remote user
          let remoteVideo = document.getElementById(`video-${remoteSocketId}`);
          if (!remoteVideo) {
            const videoWrapper = document.createElement("div");
            videoWrapper.className = "video-wrapper";
            videoWrapper.id = `wrapper-${remoteSocketId}`;

            remoteVideo = document.createElement("video");
            remoteVideo.id = `video-${remoteSocketId}`;
            remoteVideo.autoplay = true;
            remoteVideo.playsInline = true;
            // IMPORTANT: Do NOT mute remote videos by default unless intended for specific use cases.
            // remoteVideo.muted = true; // This would prevent audio from remote users

            const userIdLabel = document.createElement("div");
            userIdLabel.className = "user-id-label";
            // Use the provided remoteUserName for display
            userIdLabel.textContent = remoteUserName ? `User: ${remoteUserName}` : `User: ${remoteSocketId.substring(0, 5)}`;


            const fullscreenIconContainer = document.createElement("div");
            fullscreenIconContainer.className = "fullscreen-icon-container";
            fullscreenIconContainer.innerHTML = `
              <i class="fas fa-expand" data-target="video-${remoteSocketId}" title="Go Full Screen"></i>
              <i class="fas fa-compress" data-target="video-${remoteSocketId}" style="display: none" title="Exit Full Screen"></i>
            `;
            addFullscreenListeners(fullscreenIconContainer); // Add event listeners for this new video

            videoWrapper.appendChild(remoteVideo);
            videoWrapper.appendChild(userIdLabel);
            videoWrapper.appendChild(fullscreenIconContainer);
            videoContainer.appendChild(videoWrapper);
          }
          // THIS IS THE CRITICAL LINE for displaying the remote video
          // Assign the stream to the video element
          remoteVideo.srcObject = event.streams[0];
          callStatus.textContent = `Connected with ${remoteUserName || remoteSocketId}!`;
        };

        // Add local tracks to the new peer connection immediately after creation
        // This ensures the current user's media is sent to the new peer
        // We only add tracks if localStream is available (which it should be after initMedia)
        if (localStream) {
            if (isScreenSharing && screenStream) {
                screenStream.getTracks().forEach((track) => {
                    pc.addTrack(track, screenStream);
                });
            } else {
                localStream.getTracks().forEach((track) => {
                    pc.addTrack(track, localStream);
                });
            }
        } else {
            console.warn("localStream not available when creating peer connection for", remoteSocketId);
        }


        peerConnections[remoteSocketId] = pc;
        return pc;
      }

      // Initiate call to a specific remote user
      // Now accepts remoteUserName
      async function callUser(remoteSocketId, remoteUserName) {
        if (remoteSocketId === socket.id) {
          // Don't try to call yourself
          return;
        }

        // Only create/call if a connection doesn't exist already to prevent duplicate offers
        if (!peerConnections[remoteSocketId]) {
            const pc = createPeerConnection(remoteSocketId, remoteUserName);
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                // Send offer to the specific remote user
                socket.emit("signal", { targetId: remoteSocketId, signal: pc.localDescription });
            } catch (e) {
                console.error(`Error calling user ${remoteSocketId}:`, e);
            }
        } else {
            console.log(`Already connected to ${remoteSocketId}.`);
        }
      }

      // Remove a peer connection and its video element
      function removePeerConnection(remoteSocketId) {
        if (peerConnections[remoteSocketId]) {
          peerConnections[remoteSocketId].close();
          delete peerConnections[remoteSocketId];
        }
        const videoWrapper = document.getElementById(`wrapper-${remoteSocketId}`);
        if (videoWrapper) {
          videoContainer.removeChild(videoWrapper);
          console.log(`Removed video for ${remoteSocketId}`);
        }
      }

      // Fullscreen functionality for dynamically created video elements
      function addFullscreenListeners(container) {
        const expandBtn = container.querySelector(".fa-expand");
        const compressBtn = container.querySelector(".fa-compress");
        const videoId = expandBtn.dataset.target;
        const videoElement = document.getElementById(videoId);

        expandBtn.addEventListener("click", () => {
          if (videoElement) enterFullScreen(videoElement);
        });

        compressBtn.addEventListener("click", () => {
          exitFullScreen();
        });
      }

      // Add fullscreen listeners for the local video initially
      // This part was correct, just ensuring it's called once.
      addFullscreenListeners(localVideo.closest('.video-wrapper').querySelector('.fullscreen-icon-container'));


      // Function to request fullscreen for a video element
      function enterFullScreen(videoElement) {
        if (videoElement.requestFullscreen) {
          videoElement.requestFullscreen();
        } else if (videoElement.mozRequestFullScreen) {
          /* Firefox */
          videoElement.mozRequestFullScreen();
        } else if (videoElement.webkitRequestFullscreen) {
          /* Chrome, Safari & Opera */
          videoElement.webkitRequestFullscreen();
        } else if (videoElement.msRequestFullscreen) {
          /* IE/Edge */
          videoElement.msRequestFullscreen();
        }
      }

      // Function to exit fullscreen for a video element
      function exitFullScreen() {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          /* Firefox */
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          /* Chrome, Safari & Opera */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          /* IE/Edge */
          document.msExitFullscreen();
        }
      }

      // Listen for fullscreen change event to update button visibility
      document.addEventListener('fullscreenchange', handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.addEventListener('mozfullscreenchange', handleFullscreenChange);
      document.addEventListener('msfullscreenchange', handleFullscreenChange);

      function handleFullscreenChange() {
        const allVideoWrappers = document.querySelectorAll('.video-wrapper');
        allVideoWrappers.forEach(wrapper => {
          const videoElement = wrapper.querySelector('video');
          const expandBtn = wrapper.querySelector('.fa-expand');
          const compressBtn = wrapper.querySelector('.fa-compress');

          if (videoElement && expandBtn && compressBtn) {
            if (document.fullscreenElement === videoElement ||
                document.webkitFullscreenElement === videoElement ||
                document.mozFullScreenElement === videoElement ||
                document.msFullscreenElement === videoElement) {
              expandBtn.style.display = 'none';
              compressBtn.style.display = 'block';
            } else {
              expandBtn.style.display = 'block';
              compressBtn.style.display = 'none';
            }
          }
        });
      }

      // Toggle video
      toggleVideoBtn.onclick = () => {
        const videoTrack = getLocalVideoTrack();
        if (!videoTrack) return;

        videoTrack.enabled = !videoTrack.enabled;
        toggleVideoBtn.classList.toggle('active');
        toggleVideoBtn.innerHTML = videoTrack.enabled ?
          '<i class="fas fa-video"></i> Turn Camera Off' :
          '<i class="fas fa-video-slash"></i> Turn Camera On';

        // Notify all peer connections about the track state change
        for (const id in peerConnections) {
          const pc = peerConnections[id];
          const sender = pc.getSenders().find(s => s.track === videoTrack);
          if (sender) {
            // Although `enabled` property change propagates, for explicit control or future plans,
            // you might want to renegotiate or send a data channel message.
            // For simple enabled/disabled, WebRTC often handles this.
          }
        }
      };

      // Toggle audio
      toggleAudioBtn.onclick = () => {
        const audioTrack = getLocalAudioTrack();
        if (!audioTrack) return;

        audioTrack.enabled = !audioTrack.enabled;
        toggleAudioBtn.classList.toggle('active');
        toggleAudioBtn.innerHTML = audioTrack.enabled ?
          '<i class="fas fa-microphone"></i> Mute' :
          '<i class="fas fa-microphone-slash"></i> Unmute';

        // Notify all peer connections about the track state change
        for (const id in peerConnections) {
          const pc = peerConnections[id];
          const sender = pc.getSenders().find(s => s.track === audioTrack);
          if (sender) {
            // Same as video track: enabled/disabled usually propagates.
          }
        }
      };

      // Disconnect call
      disconnectBtn.onclick = () => {
        socket.emit("disconnect-call"); // RoomId is implicitly known by the server socket
        endCall();
      };

      function endCall() {
        // Stop all local media tracks
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localVideo.srcObject = null;
        }
        if (screenStream) {
          screenStream.getTracks().forEach((track) => track.stop());
          screenStream = null;
        }

        // Close all peer connections
        for (const remoteSocketId in peerConnections) {
          if (peerConnections[remoteSocketId]) {
            peerConnections[remoteSocketId].close();
            delete peerConnections[remoteSocketId];
          }
        }

        // Remove all remote video elements (all video wrappers except the first one which is local)
        document.querySelectorAll('.video-wrapper:not(:first-child)').forEach(el => el.remove());

        callStatus.textContent = "Call Disconnected";
        // Re-enable media buttons so user can start a new call
        toggleAudioBtn.disabled = false;
        toggleVideoBtn.disabled = false;
        shareScreenBtn.disabled = false;
        disconnectBtn.disabled = false; // Disconnect should be enabled to be pressed

        // Reset button states
        toggleVideoBtn.classList.remove('active');
        toggleVideoBtn.innerHTML = '<i class="fas fa-video"></i> Turn Camera Off';
        toggleAudioBtn.classList.remove('active');
        toggleAudioBtn.innerHTML = '<i class="fas fa-microphone"></i> Mute';
        shareScreenBtn.classList.remove('active');
        shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Share Screen';

        // Prompt for new room/user ID if they want to join again
        // This makes it easier to restart or join a different call
        // roomId = prompt("Enter room ID to join or create:");
        // if (!roomId) {
        //   roomId = "default-room-" + Math.random().toString(36).substring(2, 9);
        //   alert("No room ID entered. Joining a random room: " + roomId);
        // }
        // myUserId = prompt("Enter your user ID (e.g., 'Alice', 'Bob'):");
        // if (!myUserId) {
        //   myUserId = "user-" + Math.random().toString(36).substring(2, 6);
        //   alert("No user ID entered. Using random ID: " + myUserId);
        // }
        // roomIdDisplay.textContent = roomId;
        // myUserIdDisplay.textContent = myUserId;
        // socket.emit("join-room", roomId, myUserId);
        // initMedia(); // Re-initialize media
      }

      // Start/stop screen sharing
      shareScreenBtn.onclick = async () => {
        if (isScreenSharing) {
          stopScreenSharing();
        } else {
          startScreenSharing();
        }
      };

      async function startScreenSharing() {
        try {
          const isMobile = /iPhone|iPad|iPod|Android/i.test(
            navigator.userAgent
          );
          if (isMobile) {
            alert("Screen sharing is not fully supported on mobile browsers due to browser limitations.");
            return;
          }

          screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
          });

          const screenTrack = screenStream.getVideoTracks()[0];

          screenTrack.onended = () => {
            stopScreenSharing();
          };

          localVideo.srcObject = screenStream;
          isScreenSharing = true;
          shareScreenBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Stop Sharing';
          shareScreenBtn.classList.add('active');

          // Replace video tracks for all existing peer connections
          // Important: You should iterate through peerConnections map, not just a single peer
          for (const id in peerConnections) {
            const pc = peerConnections[id];
            const videoSender = pc.getSenders().find(sender => sender.track && sender.track.kind === 'video');
            if (videoSender) {
                await videoSender.replaceTrack(screenTrack); // Use await here
            } else {
                // If there's no video sender yet, add the track
                pc.addTrack(screenTrack, screenStream); // Add the screen track
            }
          }
        } catch (err) {
          if (err.name === 'NotAllowedError') {
              alert('Screen sharing permission denied. Please allow screen sharing to proceed.');
          } else {
              alert("Could not share screen. Please try again.");
              console.error("Error sharing screen:", err);
          }
          isScreenSharing = false;
          shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Share Screen';
          shareScreenBtn.classList.remove('active');
        }
      }

      function stopScreenSharing() {
        if (screenStream) {
          screenStream.getTracks().forEach((track) => track.stop());
          screenStream = null;
        }
        localVideo.srcObject = localStream;
        isScreenSharing = false;
        shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Share Screen';
        shareScreenBtn.classList.remove('active');

        // Replace video tracks back to camera for all existing peer connections
        const cameraVideoTrack = getLocalVideoTrack();
        if (cameraVideoTrack) { // Ensure camera video track exists before trying to replace
          for (const id in peerConnections) {
            const pc = peerConnections[id];
            const videoSender = pc.getSenders().find(sender => sender.track && sender.track.kind === 'video');
            if (videoSender) {
              videoSender.replaceTrack(cameraVideoTrack); // Replace with camera track
            } else {
                // If the sender was removed for some reason, re-add the camera track
                pc.addTrack(cameraVideoTrack, localStream);
            }
          }
        } else {
            console.warn("Local camera video track not available to revert to after screen sharing.");
            // If camera was off, consider if you want to just remove the screen track without adding camera back
            // Or if you want to explicitly start camera if it's off.
        }
      }

      // Chat functionality
      sendMessageButton.onclick = () => {
        if (chatInput.value.trim()) {
          const message = chatInput.value;
          // No need to send roomId, server knows which room this socket is in
          socket.emit("chat-message", { message: message });
          displayMessage(message, myUserId, "self-message"); // Display immediately
          chatInput.value = ""; // Clear input
        }
      };

      chatInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          sendMessageButton.click();
        }
      });

      socket.on("chat-message", (data) => {
        const { message, userId } = data; // userId is the name sent from server
        const messageType = userId === myUserId ? "self-message" : "remote-message";
        displayMessage(message, userId, messageType);
      });

      function displayMessage(message, userId, type) {
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("chat-message", type);
        messageDiv.innerHTML = `<strong>${userId}:</strong> ${message}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to bottom
      }
    </script>
  </body>
</html>