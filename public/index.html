<!DOCTYPE html>
<html>
  <head>
    <title>Simple Video Call</title>
    <style>
      video {
        width: 45%;
        margin: 5px;
        border: 1px solid black;
      }
      #controls {
        margin: 10px;
      }
      button {
        margin-right: 10px;
        padding: 8px 15px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <h1>Simple Video Call</h1>
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>

    <div id="controls">
      <button id="toggleVideo">Turn Camera Off</button>
      <button id="toggleAudio">Mute</button>
      <button id="disconnect">Disconnect Call</button>
      <button id="shareScreen">Share Screen</button>
      <!-- New button for screen sharing -->
    </div>
    <div
      id="callStatus"
      style="margin-top: 20px; font-size: 18px; color: red; font-weight: bold"
    ></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const toggleVideoBtn = document.getElementById("toggleVideo");
      const toggleAudioBtn = document.getElementById("toggleAudio");
      const disconnectBtn = document.getElementById("disconnect");
      const callStatus = document.getElementById("callStatus");
      const shareScreenBtn = document.getElementById("shareScreen"); // Share screen button

      let localStream;
      let peerConnection;
      let roomId;
      let screenStream; // Variable to store screen stream
      let isScreenSharing = false; // Flag to track if screen sharing is enabled

      const configuration = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      };

      // Initialize media and set constraints for mobile
      async function initMedia() {
        try {
          // Set lower resolution for mobile devices
          const constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
            audio: true,
          };

          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          localVideo.srcObject = localStream;
        } catch (e) {
          alert("Could not get user media");
          console.error(e);
        }
      }

      initMedia();

      roomId = prompt("Enter room ID:");
      socket.emit("join-room", roomId);

      socket.on("user-connected", (userId) => {
        console.log("User connected:", userId);
        callUser(userId);
      });

      socket.on("signal", async ({ id, signal }) => {
        if (!peerConnection) {
          createPeerConnection();
        }

        if (signal.type === "offer") {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(signal)
          );
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit("signal", peerConnection.localDescription);
        } else if (signal.type === "answer") {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(signal)
          );
        } else if (signal.candidate) {
          try {
            await peerConnection.addIceCandidate(
              new RTCIceCandidate(signal.candidate)
            );
          } catch (e) {
            console.error("Error adding received ice candidate", e);
          }
        }
      });

      socket.on("user-disconnected", (userId) => {
        console.log("User disconnected:", userId);
        endCall();
      });

      function createPeerConnection() {
        peerConnection = new RTCPeerConnection(configuration);

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit("signal", { candidate: event.candidate });
          }
        };

        peerConnection.ontrack = (event) => {
          console.log("Received remote track:", event);
          remoteVideo.srcObject = event.streams[0];
        };

        // Use the screen or video stream for the peer connection
        const streamToAdd = isScreenSharing ? screenStream : localStream;
        streamToAdd.getTracks().forEach((track) => {
          console.log("Adding track:", track);
          peerConnection.addTrack(track, streamToAdd);
        });
      }

      async function callUser(userId) {
        createPeerConnection();
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit("signal", peerConnection.localDescription);
      }

      // Toggle video
      toggleVideoBtn.onclick = () => {
        if (!localStream) return;
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack.enabled) {
          videoTrack.enabled = false;
          toggleVideoBtn.textContent = "Turn Camera On";
        } else {
          videoTrack.enabled = true;
          toggleVideoBtn.textContent = "Turn Camera Off";
        }
      };

      // Toggle audio
      toggleAudioBtn.onclick = () => {
        if (!localStream) return;
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack.enabled) {
          audioTrack.enabled = false;
          toggleAudioBtn.textContent = "Unmute";
        } else {
          audioTrack.enabled = true;
          toggleAudioBtn.textContent = "Mute";
        }
      };

      // Disconnect call
      disconnectBtn.onclick = () => {
        socket.emit("disconnect-call", roomId);
        endCall();
      };

      // End the call
      function endCall() {
        // Stop remote video
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach((track) => track.stop());
        }
        remoteVideo.srcObject = null;

        // Close peer connection
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }

        // Stop local media
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
        }
        localVideo.srcObject = null;

        // Show disconnect message
        callStatus.textContent = "Call Disconnected";

        // Optionally disable controls
        toggleAudioBtn.disabled = true;
        toggleVideoBtn.disabled = true;
        shareScreenBtn.disabled = true; // Disable screen sharing button
      }

      // Start/stop screen sharing
      shareScreenBtn.onclick = async () => {
        if (isScreenSharing) {
          stopScreenSharing();
        } else {
          startScreenSharing();
        }
      };

      async function startScreenSharing() {
        try {
          const isMobile = /iPhone|iPad|iPod|Android/i.test(
            navigator.userAgent
          );
          if (isMobile) {
            alert("Screen sharing is not supported on mobile browsers.");
            return;
          }

          // Get the screen stream
          screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
          });

          // Update the local video element
          localVideo.srcObject = screenStream;
          isScreenSharing = true;
          shareScreenBtn.textContent = "Stop Sharing Screen";

          // Replace the video track for all peer connections
          for (const userId in peerConnections) {
            peerConnections[userId].getSenders().forEach((sender) => {
              if (sender.track.kind === "video") {
                sender.replaceTrack(screenStream.getVideoTracks()[0]);
              }
            });
          }
        } catch (err) {
          alert("Could not share screen");
          console.error("Error sharing screen:", err);
        }
      }

      function stopScreenSharing() {
        const tracks = screenStream.getTracks();
        tracks.forEach((track) => track.stop());

        // Revert to the local camera stream
        localVideo.srcObject = localStream;
        isScreenSharing = false;
        shareScreenBtn.textContent = "Share Screen";

        // Replace the video track for all peer connections with the local camera video
        for (const userId in peerConnections) {
          peerConnections[userId].getSenders().forEach((sender) => {
            if (sender.track.kind === "video") {
              sender.replaceTrack(localStream.getVideoTracks()[0]);
            }
          });
        }
      }
    </script>
  </body>
</html>
